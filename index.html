import React, { useState, useEffect } from 'react';
import { Shield, Code, FileText, Search, Key, Image, Binary, Terminal, Cpu, Globe, ChevronRight, Zap, Lock, Eye, Fingerprint, Database } from 'lucide-react';
import CryptoJS from 'crypto-js';

// Professional CTF Toolkit with Cyberpunk Aesthetic
export default function CTFToolkit() {
  const [activeCategory, setActiveCategory] = useState('crypto');
  const [activeTool, setActiveTool] = useState('multi-codec');

  const categories = [
    { id: 'crypto', name: 'Cryptography', icon: Lock, color: '#00ff41' },
    { id: 'web', name: 'Web Exploitation', icon: Globe, color: '#00d9ff' },
    { id: 'forensics', name: 'Forensics', icon: Eye, color: '#ff00ff' },
    { id: 'binary', name: 'Binary/Reversing', icon: Cpu, color: '#ffaa00' },
    { id: 'osint', name: 'OSINT/Recon', icon: Search, color: '#ff0055' }
  ];

  const tools = {
    crypto: [
      { id: 'multi-codec', name: 'Multi-Codec Engine', desc: 'Advanced encoding/decoding with auto-detection' },
      { id: 'hash-analysis', name: 'Hash Analyzer', desc: 'Hash identification & cracking interface' },
      { id: 'xor-bruteforce', name: 'XOR Bruteforcer', desc: 'Multi-key XOR analysis with scoring' },
      { id: 'classical-cipher', name: 'Classical Cipher Lab', desc: 'Frequency analysis, substitution, Vigenère' },
      { id: 'rsa-toolkit', name: 'RSA Attack Toolkit', desc: 'Factor weak moduli, common attacks' }
    ],
    web: [
      { id: 'jwt-toolkit', name: 'JWT Swiss Army Knife', desc: 'Decode, verify, forge, exploit' },
      { id: 'payload-gen', name: 'Payload Generator', desc: 'SQLi, XSS, command injection payloads' },
      { id: 'request-builder', name: 'HTTP Request Builder', desc: 'Craft custom requests with headers' },
      { id: 'cookie-manipulator', name: 'Cookie Manipulator', desc: 'Parse, modify, encode cookies' }
    ],
    forensics: [
      { id: 'hex-editor', name: 'Hex Editor Pro', desc: 'Advanced hex viewer with search & extract' },
      { id: 'steg-analyzer', name: 'Steganography Analyzer', desc: 'LSB, metadata, visual filters' },
      { id: 'file-carver', name: 'File Carver', desc: 'Extract embedded files by signature' },
      { id: 'metadata-viewer', name: 'Metadata Extractor', desc: 'EXIF, PDF metadata, timestamps' }
    ],
    binary: [
      { id: 'disassembler', name: 'Disassembler', desc: 'x86/x64/ARM disassembly engine' },
      { id: 'shellcode-tester', name: 'Shellcode Tester', desc: 'Test and analyze shellcode' },
      { id: 'binary-diff', name: 'Binary Differ', desc: 'Compare binaries byte-by-byte' },
      { id: 'string-extractor', name: 'String Extractor', desc: 'Extract ASCII/Unicode strings' }
    ],
    osint: [
      { id: 'domain-recon', name: 'Domain Recon', desc: 'WHOIS, DNS, subdomain enumeration' },
      { id: 'hash-lookup', name: 'Hash Lookup', desc: 'Search leaked password databases' },
      { id: 'username-enum', name: 'Username Enumeration', desc: 'Check username across platforms' },
      { id: 'ip-intelligence', name: 'IP Intelligence', desc: 'Geolocation, ASN, threat intel' }
    ]
  };

  const currentCategory = categories.find(c => c.id === activeCategory);
  const currentTools = tools[activeCategory] || [];

  return (
    <div className="min-h-screen bg-[#0a0e1a] text-[#e0e0e0] font-mono overflow-hidden">
      {/* Animated background grid */}
      <div className="fixed inset-0 opacity-20 pointer-events-none">
        <div className="absolute inset-0" style={{
          backgroundImage: `
            linear-gradient(rgba(0, 255, 65, 0.1) 1px, transparent 1px),
            linear-gradient(90deg, rgba(0, 255, 65, 0.1) 1px, transparent 1px)
          `,
          backgroundSize: '50px 50px',
          animation: 'gridScroll 20s linear infinite'
        }}></div>
      </div>

      <style>{`
        @keyframes gridScroll {
          0% { transform: translate(0, 0); }
          100% { transform: translate(50px, 50px); }
        }
        @keyframes glowPulse {
          0%, 100% { filter: drop-shadow(0 0 8px currentColor); }
          50% { filter: drop-shadow(0 0 16px currentColor); }
        }
        @keyframes scanline {
          0% { transform: translateY(-100%); }
          100% { transform: translateY(100%); }
        }
        .glow-text {
          text-shadow: 0 0 10px currentColor, 0 0 20px currentColor, 0 0 30px currentColor;
        }
        .terminal-border {
          border: 1px solid;
          box-shadow: inset 0 0 20px rgba(0, 255, 65, 0.1), 0 0 20px rgba(0, 255, 65, 0.1);
        }
        .tool-card {
          transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .tool-card:hover {
          transform: translateY(-4px);
          box-shadow: 0 8px 32px rgba(0, 255, 65, 0.2);
        }
      `}</style>

      {/* Header */}
      <header className="relative border-b border-[#00ff41] bg-[#0a0e1a]/80 backdrop-blur-sm z-10">
        <div className="container mx-auto px-6 py-6">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-4">
              <Shield className="w-10 h-10 text-[#00ff41]" style={{ animation: 'glowPulse 2s ease-in-out infinite' }} />
              <div>
                <h1 className="text-3xl font-bold text-[#00ff41] glow-text tracking-wider">CYPHER//TOOLKIT</h1>
                <p className="text-sm text-[#00ff41]/70 mt-1">Professional CTF Arsenal v2.0</p>
              </div>
            </div>
            <div className="flex items-center gap-2 text-[#00ff41] text-sm">
              <Terminal className="w-4 h-4" />
              <span>SYSTEM READY</span>
            </div>
          </div>
        </div>
      </header>

      <div className="container mx-auto px-6 py-8">
        <div className="grid grid-cols-12 gap-6">
          {/* Sidebar */}
          <div className="col-span-3">
            <div className="terminal-border border-[#00ff41]/30 bg-[#0f1419]/80 backdrop-blur-sm rounded-lg p-4">
              <div className="flex items-center gap-2 mb-6 text-[#00ff41] text-sm font-bold">
                <Zap className="w-4 h-4" />
                <span>CATEGORIES</span>
              </div>
              
              <div className="space-y-2">
                {categories.map(category => {
                  const Icon = category.icon;
                  const isActive = activeCategory === category.id;
                  return (
                    <button
                      key={category.id}
                      onClick={() => {
                        setActiveCategory(category.id);
                        setActiveTool(tools[category.id][0].id);
                      }}
                      className={`w-full flex items-center gap-3 px-4 py-3 rounded transition-all ${
                        isActive 
                          ? 'bg-gradient-to-r from-[#00ff41]/20 to-transparent border-l-2 text-[#00ff41]' 
                          : 'text-gray-400 hover:text-gray-200 hover:bg-white/5'
                      }`}
                      style={{ borderLeftColor: isActive ? category.color : 'transparent' }}
                    >
                      <Icon className="w-5 h-5" style={{ color: category.color }} />
                      <span className="text-sm font-medium flex-1 text-left">{category.name}</span>
                      {isActive && <ChevronRight className="w-4 h-4" />}
                    </button>
                  );
                })}
              </div>

              {/* System Info */}
              <div className="mt-8 pt-6 border-t border-[#00ff41]/20">
                <div className="text-xs text-gray-500 space-y-2">
                  <div className="flex justify-between">
                    <span>Tools Loaded:</span>
                    <span className="text-[#00ff41]">{Object.values(tools).flat().length}</span>
                  </div>
                  <div className="flex justify-between">
                    <span>Active Session:</span>
                    <span className="text-[#00d9ff]">{new Date().toLocaleTimeString()}</span>
                  </div>
                </div>
              </div>
            </div>
          </div>

          {/* Main Content */}
          <div className="col-span-9">
            {/* Tools Grid */}
            <div className="mb-6">
              <div className="flex items-center gap-3 mb-4">
                <div className="h-px flex-1 bg-gradient-to-r from-transparent via-[#00ff41]/50 to-transparent"></div>
                <h2 className="text-xl font-bold uppercase tracking-wider" style={{ color: currentCategory.color }}>
                  {currentCategory.name}
                </h2>
                <div className="h-px flex-1 bg-gradient-to-r from-transparent via-[#00ff41]/50 to-transparent"></div>
              </div>

              <div className="grid grid-cols-2 gap-4">
                {currentTools.map(tool => {
                  const isActive = activeTool === tool.id;
                  return (
                    <button
                      key={tool.id}
                      onClick={() => setActiveTool(tool.id)}
                      className={`tool-card text-left p-5 rounded-lg border transition-all ${
                        isActive
                          ? 'bg-gradient-to-br from-[#00ff41]/10 to-transparent border-[#00ff41]'
                          : 'bg-[#0f1419]/80 border-gray-800 hover:border-gray-600'
                      }`}
                    >
                      <h3 className="font-bold mb-2" style={{ color: isActive ? currentCategory.color : '#e0e0e0' }}>
                        {tool.name}
                      </h3>
                      <p className="text-xs text-gray-400">{tool.desc}</p>
                    </button>
                  );
                })}
              </div>
            </div>

            {/* Tool Interface */}
            <div className="terminal-border border-[#00ff41]/30 bg-[#0f1419]/80 backdrop-blur-sm rounded-lg p-6">
              <ToolInterface category={activeCategory} tool={activeTool} color={currentCategory.color} />
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

// Tool Interface Component
function ToolInterface({ category, tool, color }) {
  const [input, setInput] = useState('');
  const [output, setOutput] = useState('');
  const [config, setConfig] = useState({});

  // Multi-Codec Engine
  const MultiCodec = () => {
    const [detectedEncoding, setDetectedEncoding] = useState('');
    
    const encodings = [
      { id: 'base64', name: 'Base64', encode: (s) => btoa(s), decode: (s) => atob(s) },
      { id: 'hex', name: 'Hexadecimal', 
        encode: (s) => Array.from(s).map(c => c.charCodeAt(0).toString(16).padStart(2, '0')).join(''),
        decode: (s) => s.match(/.{2}/g).map(h => String.fromCharCode(parseInt(h, 16))).join('')
      },
      { id: 'url', name: 'URL Encoding', encode: encodeURIComponent, decode: decodeURIComponent },
      { id: 'rot13', name: 'ROT13', 
        encode: (s) => s.replace(/[a-zA-Z]/g, c => String.fromCharCode(c.charCodeAt(0) + (c.toLowerCase() < 'n' ? 13 : -13))),
        decode: (s) => s.replace(/[a-zA-Z]/g, c => String.fromCharCode(c.charCodeAt(0) + (c.toLowerCase() < 'n' ? 13 : -13)))
      },
      { id: 'binary', name: 'Binary',
        encode: (s) => s.split('').map(c => c.charCodeAt(0).toString(2).padStart(8, '0')).join(' '),
        decode: (s) => s.split(' ').map(b => String.fromCharCode(parseInt(b, 2))).join('')
      },
      { id: 'morse', name: 'Morse Code',
        encode: (s) => {
          const morse = {'A':'.-','B':'-...','C':'-.-.','D':'-..','E':'.','F':'..-.','G':'--.','H':'....','I':'..','J':'.---','K':'-.-','L':'.-..','M':'--','N':'-.','O':'---','P':'.--.','Q':'--.-','R':'.-.','S':'...','T':'-','U':'..-','V':'...-','W':'.--','X':'-..-','Y':'-.--','Z':'--..','0':'-----','1':'.----','2':'..---','3':'...--','4':'....-','5':'.....','6':'-....','7':'--...','8':'---..','9':'----.', ' ':'/'};
          return s.toUpperCase().split('').map(c => morse[c] || c).join(' ');
        },
        decode: (s) => {
          const morse = {'.-':'A','-...':'B','-.-.':'C','-..':'D','.':'E','..-.':'F','--.':'G','....':'H','..':'I','.---':'J','-.-':'K','.-..':'L','--':'M','-.':'N','---':'O','.--.':'P','--.-':'Q','.-.':'R','...':'S','-':'T','..-':'U','...-':'V','.--':'W','-..-':'X','-.--':'Y','--..':'Z','-----':'0','.----':'1','..---':'2','...--':'3','....-':'4','.....':'5','-....':'6','--...':'7','---..':'8','----.':'9', '/':' '};
          return s.split(' ').map(m => morse[m] || m).join('');
        }
      }
    ];

    const detectEncoding = (str) => {
      if (/^[A-Za-z0-9+/]+=*$/.test(str) && str.length % 4 === 0) return 'base64';
      if (/^[0-9a-fA-F]+$/.test(str)) return 'hex';
      if (/%[0-9A-F]{2}/.test(str)) return 'url';
      if (/^[01\s]+$/.test(str)) return 'binary';
      if (/^[.-\/\s]+$/.test(str)) return 'morse';
      return 'unknown';
    };

    const handleEncode = (encoding) => {
      try {
        const encoded = encodings.find(e => e.id === encoding).encode(input);
        setOutput(encoded);
      } catch (e) {
        setOutput('Error: ' + e.message);
      }
    };

    const handleDecode = (encoding) => {
      try {
        const decoded = encodings.find(e => e.id === encoding).decode(input);
        setOutput(decoded);
      } catch (e) {
        setOutput('Error: ' + e.message);
      }
    };

    const autoDetect = () => {
      const detected = detectEncoding(input);
      setDetectedEncoding(detected);
      if (detected !== 'unknown') {
        handleDecode(detected);
      } else {
        setOutput('Unable to auto-detect encoding');
      }
    };

    return (
      <div className="space-y-4">
        <div className="flex items-center justify-between mb-4">
          <h3 className="text-lg font-bold" style={{ color }}>Multi-Codec Engine</h3>
          <button
            onClick={autoDetect}
            className="px-4 py-2 bg-[#00ff41]/20 hover:bg-[#00ff41]/30 border border-[#00ff41] rounded text-[#00ff41] text-sm font-bold transition-all"
          >
            <Fingerprint className="w-4 h-4 inline mr-2" />
            AUTO-DETECT
          </button>
        </div>

        {detectedEncoding && detectedEncoding !== 'unknown' && (
          <div className="bg-[#00ff41]/10 border border-[#00ff41]/30 rounded p-3 text-sm">
            <strong className="text-[#00ff41]">Detected:</strong> {detectedEncoding.toUpperCase()}
          </div>
        )}

        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-bold mb-2 text-gray-400">INPUT</label>
            <textarea
              value={input}
              onChange={(e) => setInput(e.target.value)}
              className="w-full h-48 bg-black/50 border border-gray-700 rounded p-3 text-sm font-mono focus:border-[#00ff41] focus:outline-none resize-none"
              placeholder="Enter text to encode/decode..."
            />
          </div>
          <div>
            <label className="block text-sm font-bold mb-2 text-gray-400">OUTPUT</label>
            <textarea
              value={output}
              readOnly
              className="w-full h-48 bg-black/50 border border-gray-700 rounded p-3 text-sm font-mono resize-none"
              placeholder="Output will appear here..."
            />
          </div>
        </div>

        <div className="grid grid-cols-3 gap-2">
          {encodings.map(enc => (
            <div key={enc.id} className="flex gap-2">
              <button
                onClick={() => handleEncode(enc.id)}
                className="flex-1 px-3 py-2 bg-blue-600/20 hover:bg-blue-600/30 border border-blue-500 rounded text-xs font-bold transition-all"
              >
                → {enc.name}
              </button>
              <button
                onClick={() => handleDecode(enc.id)}
                className="flex-1 px-3 py-2 bg-purple-600/20 hover:bg-purple-600/30 border border-purple-500 rounded text-xs font-bold transition-all"
              >
                ← {enc.name}
              </button>
            </div>
          ))}
        </div>
      </div>
    );
  };

  // Hash Analyzer
  const HashAnalyzer = () => {
    const [hashType, setHashType] = useState('');
    const [hashInfo, setHashInfo] = useState(null);

    const hashPatterns = [
      { name: 'MD5', regex: /^[a-f0-9]{32}$/i, length: 32 },
      { name: 'SHA-1', regex: /^[a-f0-9]{40}$/i, length: 40 },
      { name: 'SHA-256', regex: /^[a-f0-9]{64}$/i, length: 64 },
      { name: 'SHA-512', regex: /^[a-f0-9]{128}$/i, length: 128 },
      { name: 'bcrypt', regex: /^\$2[aby]\$\d{2}\$[./A-Za-z0-9]{53}$/, length: 60 },
      { name: 'NTLM', regex: /^[a-f0-9]{32}$/i, length: 32 }
    ];

    const analyzeHash = () => {
      const trimmed = input.trim();
      const matches = hashPatterns.filter(p => p.regex.test(trimmed));
      
      if (matches.length > 0) {
        setHashType(matches.map(m => m.name).join(' or '));
        
        // Generate hash for comparison
        const testString = 'password123';
        const hashes = {
          'MD5': CryptoJS.MD5(testString).toString(),
          'SHA-1': CryptoJS.SHA1(testString).toString(),
          'SHA-256': CryptoJS.SHA256(testString).toString(),
          'SHA-512': CryptoJS.SHA512(testString).toString()
        };
        
        setHashInfo({
          length: trimmed.length,
          possibleTypes: matches.map(m => m.name),
          example: hashes[matches[0].name] || 'N/A'
        });
        
        setOutput(`Identified: ${matches.map(m => m.name).join(' or ')}\nLength: ${trimmed.length} characters`);
      } else {
        setHashType('Unknown');
        setOutput('Unable to identify hash type. Please verify the hash format.');
      }
    };

    const generateHash = (algorithm) => {
      try {
        let hash;
        switch(algorithm) {
          case 'MD5': hash = CryptoJS.MD5(input).toString(); break;
          case 'SHA-1': hash = CryptoJS.SHA1(input).toString(); break;
          case 'SHA-256': hash = CryptoJS.SHA256(input).toString(); break;
          case 'SHA-512': hash = CryptoJS.SHA512(input).toString(); break;
          default: hash = 'Unknown algorithm';
        }
        setOutput(hash);
      } catch (e) {
        setOutput('Error: ' + e.message);
      }
    };

    return (
      <div className="space-y-4">
        <h3 className="text-lg font-bold mb-4" style={{ color }}>Hash Analysis & Generation</h3>

        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-bold mb-2 text-gray-400">INPUT</label>
            <textarea
              value={input}
              onChange={(e) => setInput(e.target.value)}
              className="w-full h-32 bg-black/50 border border-gray-700 rounded p-3 text-sm font-mono focus:border-[#00ff41] focus:outline-none resize-none"
              placeholder="Enter hash to analyze or text to hash..."
            />
          </div>
          <div>
            <label className="block text-sm font-bold mb-2 text-gray-400">OUTPUT</label>
            <textarea
              value={output}
              readOnly
              className="w-full h-32 bg-black/50 border border-gray-700 rounded p-3 text-sm font-mono resize-none"
              placeholder="Results will appear here..."
            />
          </div>
        </div>

        <div className="flex gap-4">
          <div className="flex-1">
            <h4 className="text-sm font-bold mb-2 text-gray-400">ANALYZE HASH</h4>
            <button
              onClick={analyzeHash}
              className="w-full px-4 py-3 bg-[#ff00ff]/20 hover:bg-[#ff00ff]/30 border border-[#ff00ff] rounded text-[#ff00ff] font-bold transition-all"
            >
              <Eye className="w-4 h-4 inline mr-2" />
              IDENTIFY HASH TYPE
            </button>
          </div>
          
          <div className="flex-1">
            <h4 className="text-sm font-bold mb-2 text-gray-400">GENERATE HASH</h4>
            <div className="grid grid-cols-2 gap-2">
              {['MD5', 'SHA-1', 'SHA-256', 'SHA-512'].map(algo => (
                <button
                  key={algo}
                  onClick={() => generateHash(algo)}
                  className="px-3 py-2 bg-[#00d9ff]/20 hover:bg-[#00d9ff]/30 border border-[#00d9ff] rounded text-xs font-bold transition-all"
                >
                  {algo}
                </button>
              ))}
            </div>
          </div>
        </div>

        {hashInfo && (
          <div className="bg-[#00ff41]/10 border border-[#00ff41]/30 rounded p-4">
            <h4 className="text-sm font-bold mb-2 text-[#00ff41]">HASH INTELLIGENCE</h4>
            <div className="space-y-1 text-sm font-mono">
              <div><span className="text-gray-400">Possible Types:</span> {hashInfo.possibleTypes.join(', ')}</div>
              <div><span className="text-gray-400">Length:</span> {hashInfo.length} chars</div>
              <div><span className="text-gray-400">Example Hash:</span> <span className="text-xs break-all">{hashInfo.example}</span></div>
            </div>
          </div>
        )}
      </div>
    );
  };

  // XOR Bruteforcer
  const XORBruteforce = () => {
    const [results, setResults] = useState([]);
    const [keyLength, setKeyLength] = useState(1);

    const xorBruteforce = () => {
      const data = input;
      const resultList = [];
      
      // Single-byte XOR
      if (keyLength === 1) {
        for (let key = 0; key < 256; key++) {
          let decoded = '';
          let score = 0;
          
          for (let i = 0; i < data.length; i++) {
            const char = data.charCodeAt(i) ^ key;
            decoded += String.fromCharCode(char);
            
            // Score based on printable ASCII and common letters
            if (char >= 32 && char <= 126) score += 1;
            if ('etaoinshrdlu'.includes(String.fromCharCode(char).toLowerCase())) score += 2;
          }
          
          resultList.push({
            key: key.toString(16).padStart(2, '0'),
            score,
            preview: decoded.substring(0, 50)
          });
        }
      }
      
      resultList.sort((a, b) => b.score - a.score);
      setResults(resultList.slice(0, 10));
      setOutput(`Top ${Math.min(10, resultList.length)} results by scoring`);
    };

    return (
      <div className="space-y-4">
        <h3 className="text-lg font-bold mb-4" style={{ color }}>XOR Bruteforce Attack</h3>

        <div>
          <label className="block text-sm font-bold mb-2 text-gray-400">ENCRYPTED DATA (Hex or ASCII)</label>
          <textarea
            value={input}
            onChange={(e) => setInput(e.target.value)}
            className="w-full h-24 bg-black/50 border border-gray-700 rounded p-3 text-sm font-mono focus:border-[#00ff41] focus:outline-none resize-none"
            placeholder="Enter encrypted data..."
          />
        </div>

        <div className="flex gap-4 items-end">
          <div className="flex-1">
            <label className="block text-sm font-bold mb-2 text-gray-400">KEY LENGTH</label>
            <input
              type="number"
              value={keyLength}
              onChange={(e) => setKeyLength(parseInt(e.target.value))}
              min="1"
              max="16"
              className="w-full px-4 py-2 bg-black/50 border border-gray-700 rounded font-mono focus:border-[#00ff41] focus:outline-none"
            />
          </div>
          <button
            onClick={xorBruteforce}
            className="px-6 py-2 bg-[#ff00ff]/20 hover:bg-[#ff00ff]/30 border border-[#ff00ff] rounded text-[#ff00ff] font-bold transition-all"
          >
            <Zap className="w-4 h-4 inline mr-2" />
            BRUTEFORCE
          </button>
        </div>

        {results.length > 0 && (
          <div className="bg-black/50 border border-gray-700 rounded p-4">
            <h4 className="text-sm font-bold mb-3 text-[#00ff41]">TOP CANDIDATES (by scoring)</h4>
            <div className="space-y-2 max-h-64 overflow-y-auto">
              {results.map((result, idx) => (
                <div key={idx} className="bg-[#0f1419] border border-gray-800 rounded p-3 hover:border-[#00ff41]/50 transition-colors cursor-pointer"
                  onClick={() => setOutput(result.preview)}>
                  <div className="flex justify-between mb-1">
                    <span className="text-[#00ff41] font-bold text-xs">Key: 0x{result.key}</span>
                    <span className="text-gray-400 text-xs">Score: {result.score}</span>
                  </div>
                  <div className="text-xs font-mono text-gray-300 truncate">{result.preview}</div>
                </div>
              ))}
            </div>
          </div>
        )}

        <div>
          <label className="block text-sm font-bold mb-2 text-gray-400">SELECTED OUTPUT</label>
          <textarea
            value={output}
            readOnly
            className="w-full h-32 bg-black/50 border border-gray-700 rounded p-3 text-sm font-mono resize-none"
            placeholder="Click on a candidate to view full output..."
          />
        </div>
      </div>
    );
  };

  // JWT Toolkit
  const JWTToolkit = () => {
    const [decodedHeader, setDecodedHeader] = useState('');
    const [decodedPayload, setDecodedPayload] = useState('');
    const [signature, setSignature] = useState('');

    const decodeJWT = () => {
      try {
        const parts = input.split('.');
        if (parts.length !== 3) {
          setOutput('Invalid JWT format');
          return;
        }

        const header = JSON.parse(atob(parts[0]));
        const payload = JSON.parse(atob(parts[1]));
        
        setDecodedHeader(JSON.stringify(header, null, 2));
        setDecodedPayload(JSON.stringify(payload, null, 2));
        setSignature(parts[2]);
        setOutput('JWT decoded successfully');
      } catch (e) {
        setOutput('Error decoding JWT: ' + e.message);
      }
    };

    const modifyJWT = () => {
      try {
        const header = JSON.parse(decodedHeader);
        const payload = JSON.parse(decodedPayload);
        
        const newHeader = btoa(JSON.stringify(header)).replace(/=/g, '');
        const newPayload = btoa(JSON.stringify(payload)).replace(/=/g, '');
        
        const newJWT = `${newHeader}.${newPayload}.${signature}`;
        setOutput(newJWT);
      } catch (e) {
        setOutput('Error: ' + e.message);
      }
    };

    return (
      <div className="space-y-4">
        <h3 className="text-lg font-bold mb-4" style={{ color }}>JWT Swiss Army Knife</h3>

        <div>
          <label className="block text-sm font-bold mb-2 text-gray-400">JWT TOKEN</label>
          <textarea
            value={input}
            onChange={(e) => setInput(e.target.value)}
            className="w-full h-20 bg-black/50 border border-gray-700 rounded p-3 text-sm font-mono focus:border-[#00ff41] focus:outline-none resize-none"
            placeholder="Paste JWT token here..."
          />
        </div>

        <button
          onClick={decodeJWT}
          className="w-full px-4 py-3 bg-[#00d9ff]/20 hover:bg-[#00d9ff]/30 border border-[#00d9ff] rounded text-[#00d9ff] font-bold transition-all"
        >
          <Key className="w-4 h-4 inline mr-2" />
          DECODE JWT
        </button>

        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-bold mb-2 text-gray-400">HEADER</label>
            <textarea
              value={decodedHeader}
              onChange={(e) => setDecodedHeader(e.target.value)}
              className="w-full h-32 bg-black/50 border border-gray-700 rounded p-3 text-xs font-mono focus:border-[#00ff41] focus:outline-none resize-none"
              placeholder='{"alg": "HS256", "typ": "JWT"}'
            />
          </div>
          <div>
            <label className="block text-sm font-bold mb-2 text-gray-400">PAYLOAD</label>
            <textarea
              value={decodedPayload}
              onChange={(e) => setDecodedPayload(e.target.value)}
              className="w-full h-32 bg-black/50 border border-gray-700 rounded p-3 text-xs font-mono focus:border-[#00ff41] focus:outline-none resize-none"
              placeholder='{"sub": "1234567890", "name": "John Doe"}'
            />
          </div>
        </div>

        <div>
          <label className="block text-sm font-bold mb-2 text-gray-400">SIGNATURE</label>
          <input
            type="text"
            value={signature}
            onChange={(e) => setSignature(e.target.value)}
            className="w-full px-4 py-2 bg-black/50 border border-gray-700 rounded font-mono text-sm focus:border-[#00ff41] focus:outline-none"
            placeholder="Signature will appear here..."
          />
        </div>

        <button
          onClick={modifyJWT}
          className="w-full px-4 py-3 bg-[#ff00ff]/20 hover:bg-[#ff00ff]/30 border border-[#ff00ff] rounded text-[#ff00ff] font-bold transition-all"
        >
          FORGE MODIFIED JWT
        </button>

        <div>
          <label className="block text-sm font-bold mb-2 text-gray-400">OUTPUT / MODIFIED JWT</label>
          <textarea
            value={output}
            readOnly
            className="w-full h-24 bg-black/50 border border-gray-700 rounded p-3 text-sm font-mono resize-none"
            placeholder="Modified JWT will appear here..."
          />
        </div>

        <div className="bg-yellow-900/20 border border-yellow-500/30 rounded p-3 text-xs text-yellow-300">
          <strong>⚠ Security Note:</strong> This tool can test for vulnerabilities like 'none' algorithm bypass, weak secret keys, and algorithm confusion attacks.
        </div>
      </div>
    );
  };

  // Hex Editor
  const HexEditor = () => {
    const [hexData, setHexData] = useState('');
    const [searchTerm, setSearchTerm] = useState('');

    const textToHex = () => {
      const hex = Array.from(input)
        .map((c, i) => {
          const h = c.charCodeAt(0).toString(16).padStart(2, '0');
          return (i % 16 === 0 ? '
' : '') + h + ' ';
        })
        .join('');
      setHexData(hex);
      setOutput(hex);
    };

    const hexToText = () => {
      try {
        const cleaned = hexData.replace(/[^0-9a-f]/gi, '');
        const text = cleaned.match(/.{2}/g)
          .map(h => String.fromCharCode(parseInt(h, 16)))
          .join('');
        setOutput(text);
      } catch (e) {
        setOutput('Error: ' + e.message);
      }
    };

    const searchHex = () => {
      const searchHex = Array.from(searchTerm)
        .map(c => c.charCodeAt(0).toString(16).padStart(2, '0'))
        .join(' ');
      
      if (hexData.includes(searchHex)) {
        setOutput(`Found "${searchTerm}" at position: ${hexData.indexOf(searchHex)}`);
      } else {
        setOutput(`Pattern "${searchTerm}" not found`);
      }
    };

    return (
      <div className="space-y-4">
        <h3 className="text-lg font-bold mb-4" style={{ color }}>Hex Editor Pro</h3>

        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-bold mb-2 text-gray-400">TEXT INPUT</label>
            <textarea
              value={input}
              onChange={(e) => setInput(e.target.value)}
              className="w-full h-32 bg-black/50 border border-gray-700 rounded p-3 text-sm font-mono focus:border-[#00ff41] focus:outline-none resize-none"
              placeholder="Enter text to convert to hex..."
            />
            <button
              onClick={textToHex}
              className="mt-2 w-full px-4 py-2 bg-[#00d9ff]/20 hover:bg-[#00d9ff]/30 border border-[#00d9ff] rounded text-xs font-bold transition-all"
            >
              TEXT → HEX
            </button>
          </div>
          <div>
            <label className="block text-sm font-bold mb-2 text-gray-400">HEX VIEW</label>
            <textarea
              value={hexData}
              onChange={(e) => setHexData(e.target.value)}
              className="w-full h-32 bg-black/50 border border-gray-700 rounded p-3 text-sm font-mono focus:border-[#00ff41] focus:outline-none resize-none"
              placeholder="Hex data will appear here..."
            />
            <button
              onClick={hexToText}
              className="mt-2 w-full px-4 py-2 bg-[#ff00ff]/20 hover:bg-[#ff00ff]/30 border border-[#ff00ff] rounded text-xs font-bold transition-all"
            >
              HEX → TEXT
            </button>
          </div>
        </div>

        <div className="flex gap-2">
          <input
            type="text"
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="flex-1 px-4 py-2 bg-black/50 border border-gray-700 rounded font-mono text-sm focus:border-[#00ff41] focus:outline-none"
            placeholder="Search for pattern..."
          />
          <button
            onClick={searchHex}
            className="px-6 py-2 bg-[#00ff41]/20 hover:bg-[#00ff41]/30 border border-[#00ff41] rounded text-[#00ff41] font-bold transition-all"
          >
            <Search className="w-4 h-4 inline mr-2" />
            SEARCH
          </button>
        </div>

        <div>
          <label className="block text-sm font-bold mb-2 text-gray-400">OUTPUT</label>
          <textarea
            value={output}
            readOnly
            className="w-full h-32 bg-black/50 border border-gray-700 rounded p-3 text-sm font-mono resize-none"
            placeholder="Output will appear here..."
          />
        </div>
      </div>
    );
  };

  // Render the appropriate tool
  const renderTool = () => {
    switch (tool) {
      case 'multi-codec': return <MultiCodec />;
      case 'hash-analysis': return <HashAnalyzer />;
      case 'xor-bruteforce': return <XORBruteforce />;
      case 'jwt-toolkit': return <JWTToolkit />;
      case 'hex-editor': return <HexEditor />;
      default: return (
        <div className="text-center py-12 text-gray-500">
          <Terminal className="w-16 h-16 mx-auto mb-4 opacity-50" />
          <p className="text-lg font-bold">Tool Implementation In Progress</p>
          <p className="text-sm mt-2">This tool will be available in the next update</p>
        </div>
      );
    }
  };

  return (
    <div>
      {renderTool()}
    </div>
  );
}
